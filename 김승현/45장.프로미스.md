# promise

자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 콜백 패턴은 조금만 연속되어도 가독성이 나쁘고 비동기 처리 중 발생한 예외 처리가 곤란하여 여러 개의 비동기 처리를 한번에 처리하는데 한계가 있다.
이러한 부분을 보완하고자 ES6에서 프로미스(Promise)를 도입하였다. 프로미스는 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.

</br>

## 비동기 처리를 위한 콜백 패턴의 단점

### 1. 콜백 헬

어떠한 함수를 실행했을 때, 해당 함수 내부의 비동기 함수가 완료되지 않았다해도, 비동기 함수를 기다리지 않고 즉시 종료된다.

ex) setTimeout 비동기 함수

```javascript
let g = 0;
setTimeout(() => {
  g = 100;
}, 0);
console.log(g); // 0
```

ex) get요청 비동기 함수

```javascript
const get = (url) => {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.send();

  xhr.onload = () => {
    return JSON.parse(xhr.response);
  };
};

const res = get("https://tistory.com");
console.log(res); // undefined
```

get 함수 내부의 onload 이벤트 핸들러는 비동기로 동작한다.
get 함수를 호출하면, GET 요청을 전송하고 onload 이벤트를 등록한 다음 undefined를 반환하고 즉시 종료된다.

`onload 이벤트 : 문서의 모든 콘텐츠가 로드된 후 발생하는 이벤트`

비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다.
따라서 비동기 함수의 처리 결과는 함수 내부에서 수행해야 한다.

그래서 보통, 비동기 처리 결과에 대한 후속 처리를 위해 콜백 함수를 전달한다.

```javascript
const get = (url, returnCallback) => {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.send();

  xhr.onload = () => {
    return JSON.parse(xhr.response);
  };
};

const res = get("https://00.com", console.log);
console.log(res); // 서버에서 받은 응답이 출력된다.
```

하지만, 콜백함수를 통해 비동기 처리 결과에 대한 후속처리가 필요하게 된다면, 콜백 함수 호출이 중첩되어 복잡도가 늘어난다. 이것을 콜백 헬이라고 한다.

</br>

### 2. 에러 처리의 한계

콜백 패턴의 심각한 문제점으로, 에러 처리가 어렵다는 점이다.

```javascript
try {
  setTimeout(() => {
    throw new Error("Error");
  });
} catch (e) {
  console.log(e);
}
```

위 코드에서 error는 캐치되지 않는다.
에러는 호출자 방향으로 전파되는데(오류가 발생한 지점에서 호출된 상위 함수로 전파된다는 의미), setTimeout 함수의 콜백 함수를 호출한 것은 setTimeout이 아니므로, catch 블록에서 캐치되지 않는다고 한다. (setTimeout의 콜백함수가 실행될 때 setTimeout함수는 이미 콜스택에서 제거된 상태이기 때문.)

</br>

## 2. 프로미스의 생성

```javascript
const promiseGet = (url) => {
  return new Promise((resolve, reject) => {
    // Promise 함수의 콜백 함수 내부에서 비동기 처리 수행
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.send();

    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.response));
      } else {
        reject(new Error(xhr.status));
      }
    };
  });
};

// promiseGet 함수는 프로미스를 반환함
promiseGet("https://00.com");
```

1. 사용 방법

   ```
   const promise = new Promise((resolve, reject) => {})
   ```

   - resolve : 비동기 처리 성공 시 실행하는 함수
   - reject : 비동기 처리 실패 시 실행하는 함수

2. 프로미스의 상태

   - pending : 비동기 처리가 아직 수행되지 않은 상태(프로미스 생성된 후 직후 기본 상태)
   - fulfilled : 비동기 처리가 수행된 (성공) 상태(resolve 함수 호출)
   - rejected : 비동기 처리가 수행된 (실패) 상태 (reject 함수 호출)

fulfilled 또는 rejected 상태를 settled 상태라고 하며, settled상태가 되면 다른 상태로 변화할 수 없다.

</br>

## 3. 프로미스의 후속 처리 메서드

프로미스의 처리 결과에 따른 메서드로 then, catch, finally를 제공한다.
모든 후속 처리 메서드는 프로미스를 반환하며, 비동기로 동작한다.

1. Promise.prototype.then

   - 첫 번째 콜백 함수는 프로미스가 fulfilled 상태가 되면 호출한다.
   - 두 번째 콜백 함수는 프로미스가 rejected 상태가 되면 호출한다.

   ```javascript
   new Promise((resolve) => resolve("fullfilled")).then(
     (v) => console.log(v),
     (e) => console.error(e)
   );
   ```

   두 콜백함수 모두 프로미스의 결과를 인수로 전달받는다.

   </br>

2. Promise.prototype.catch

   catch는 프로미스가 rejected 상태일 경우에만 호출되며, 한 개의 콜백 함수를 인자로 전달받는다.

   ```javascript
   new Promise((_, reject) => reject("fulfilled")).catch(
     (v) => console.log(v),
     (e) => console.error(e)
   );
   ```

   </br>

3. Promise.prototype.finally

   프로미스의 성공/실패와 상관없이 무조건 한 번 호출된다.
   상태와 상관없이 공통적으로 수행해야하는 내용이 있을 경우 유용한 메서드이다.

   ```javascript
   new Promise(() => {}).finally(() => console.log("finally"));
   ```

   </br>

## 4. 프로미스의 에러 처리

then 메서드의 두번째 콜백 함수는 첫 번째 콜백 함수에서 발생한 에러를 캐치하지 못하고, 코드가 복잡해져서 가독성이 좋지않기 때문에 then, catch문을 쓰는것이 더욱 좋다.
catch 메서드를 모든 then메서드 호출 이후에 호출하면 then 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있다.

```javascript
// then의 두번째 콜백 함수를 통한 에러 처리
promiseGet("https://00.com").then(
  (res) => console.log(res),
  (err) => console.log(err)
);

// catch 메서드를 통한 에러 처리
promiseGet("https://00.com")
  .then((res) => console.log(res))
  .catch((err) => console.log(err));
```

 </br>

## 5. 프로미스 체이닝

then, catch, finally 와 같은 후속 처리 메서드는 항상 프로미스를 반환하기 때문에 연속적으로 호출이 가능하며, 이러한 형태를 프로미스 체이닝이라고 한다.

```javascript
promiseGet(`${url}/community`)
  .then(({ userId }) => promiseGet(`${url}/users/${userId}`))
  .then((userInfo) => console.log(userInfo))
  .catch((err) => console.error(err));
```

하지만 가독성이 좋지않기때문에 es8에서 도입된 async/await을 사용하는 것을 권장한다.

```javascript
async () => {
  const { userId } = await promiseGet(`${url}/community`);
  const userInfo = await promiseGet(`${url}/users/${userId}`);

  console.log(userInfo);
};
```

 </br>

## 6. 프로미스의 정적 메서드

1. Promise.resolve/ Promise.reject

   위 메서드는 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다.

   ```javascript
   const resolvedPromise = Promise.resolve([1, 2, 3]);
   resolvePromise.then();
   ```

2. Promise.all

   여러 개의 비동기 처리를 순차적으로 처리하는 것이 아닌, 모두 병렬로 처리할 때 사용한다.

   ```javascript
   Promise.all([requestData1(), requestData2(), requestData3()])
     .then(console.log)
     .catch(console.error);
   ```

   `마치 동시에 실행되는 것처럼 보이지만, 실행 순서 자체는 매개변수로 들어간 배열 순서대로 실행된다.`

   Promise.all로 전달받는 모든 프로미스가 모두 fulfilled(성공) 상태가 되면 모든 처리 결과를 배열에 저장하여 새로운 프로미스를 반환한다.

   인수로 전달받은 배열의 프로미스가 하나라도 rejected 상태가 되면 나머지 프로미스가 fulfilled상태가 되는 것을 기다리지 않고 즉시 종료한다.

   따라서 rejected된 단일 promise만 catch문에 잡힌다.

3. Promise.race

   Promise.all과 비슷하지만, 모든 프로미스가 fulfilled 상태가 되기를 기다리는 것이 아닌, 가장 먼저 fulfilled 상태가 된 프로미스 처리 결과를 resolve하는 새로운 프로미스를 반환한다.

   프로미스가 rejected상태가 되면 Promise.all과 동일하게 처리된다.

4. Promise.allSettled

   인수로 전달받은 프로미스가 모두 settled상태가 되면 처리 결과를 배열로 반환한다.

   `어떠한 프로미스가 reject되더라도 catch문은 실행되지 않는다.`

 </br>

## 7. 마이크로태스크 큐

```javascript
setTimeout(() => console.log(1), 0);

Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));

// 결과 : 2, 3, 1
```

프로미스의 후속 처리 메서드(then)의 콜백 함수는 태스크 큐가 아니라 마이크로태스크 큐에 저장된다.
마이크로태스크 큐는 태스크 큐보다 우선순위가 높다.

즉, 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수를 실행하고, 이후 태스크 큐에서 가져와 실행한다.

 </br>

## 8. fetch

XMLHttpRequest객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 `클라이언트 사이드 Web Api`이다.
XMLHttpRequest 객체보다 사용법이 간단하고, 프로미스를 지원한다는 특징이 있다.

단, fetch는 `브라우저 환경에서만` 제공되며, Node.js와 같은 환경에서는 사용이 불가능하다. 이때는 axios, http라이브러리를 사용해야한다.

```javascript
const promise = fetch(url, [, options]);
```

fetch 함수는 HTTP응답을 나타내는 Response객체를 래핑한 Promise객체를 반환한다.

```javascript
fetch(`${url}`).then((response) => console.log(response));
```

fetch함수가 반환한 응답 몸체를 취득하려면 Response.prototype.json 메서드를 사용한다.
