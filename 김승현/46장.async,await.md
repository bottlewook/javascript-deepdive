(제너레이터를 사용하여 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있지만 코드가 상당히 길어지고 복잡해진다.)

ES8에서 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있는 async/await이 도입되었다.

async/await은 프로미스를 기반으로 동작하며, async/await을 사용하면 프로미스의 후속 처리 메서드(then, catch, finally)를 사용하지 않고 동기처럼 프로미스를 사용할 수 있다.

```javascript
async function fetchTodo() {
  const url = "https://jsonplaceholder.typicode.com/todos/1";

  const response = await fetch(url);
  const todo = await response.json();

  console.log(todo);
  // {userId: 1, id: 1, title: 'delectus aut autem', completed: false}
}

fetchTodo();
```

## async 함수

- await 키워드는 반드시 async 함수 내부에서 사용해야 한다.
- async함수는 async 키워드를 사용하여 정의할 수 있으며 언제나 프로미스를 반환한다.
- async 함수가 명시적으로 프로미스를 반환하지 않더라도 async 함수는 암묵적으로 반환값을 resolve하는 프로미스를 반환한다.

```javascript
// 함수 선언문
async function test(name) {
  return name;
}

test("cat").then((name) => console.log(name)); // 'cat'
```

## await 키워드

await키워드는 프로미스가 settled 상태가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과를 반환한다. 반드시 프로미스 앞에서 사용해야 한다.

비동기 처리의 처리 순서가 보장되어야하는 경우 await 키워드를 사용하여 순차적으로 처리하는 것이 좋다.

```javascript
async function bar(id) {
  const name = await getUserName(id);
  const email = await getUserEmail(id);
}

bar(1);
```

## 에러 처리

비동기 처리를 위한 콜백 패턴의 단점 중 가장 심각한 것은 에러 처리가 곤란하다는 점이지만,
async/await에서 에러 처리는 try catch문을 사용할 수 있다. 콜백 함수를 인자로 전달받는 비동기 함수와는 달리 프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있기 때문에 호출자가 명확하다.

async함수 내에서 catch 문을 사용하여 에러 처리를 하지않으면 async 함수는 발생한 에러를 reject하는 프로미스를 반환하기 때문에 후속 처리 메서드를 사용하여 에러를 캐치할 수도 있다.

```javascript
const foo = async () => {
  try {
    const url = "https://wrong.url";

    const response = await fetch(url);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error); // TypeError : Failed to fetch
  }
};
foo();
```
