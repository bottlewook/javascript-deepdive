함수
====

## 함수란 무엇인가요?
- 일급 객체, 즉 **값**으로 표현됨
- **수학**의 함수(*입력*(인수)을 받아 *출력*(반환값)을 내보내는 일련의 과정)와 같은 개념
- 일련의 과정을 **문**으로 구현하고 **코드 블록**으로 감싸서 **하나의 실행 단위**로 정의한 것

*인수는 함수 호출에 쓰이는 값이고 매개변수는 함수 정의에 쓰이는 변수입니다.*

## 함수를 썼을 때의 장점은 무엇이 있나요?
- **코드의 재사용**이라는 측면에서 매우 유용함
    - 즉, 이로 인해 **유지보수의 편의성**과 **코드의 신뢰성**에도 좋은 효과를 얻음
- 코드는 **개발자를 위한 문서**이기도 하기 때문에, **적절한 함수 이름**을 썼을 경우 **코드의 가독성**을 향상

유지보수의 편의성 : 코드의 중복을 억제하고 재사용성 향상
코드의 신뢰성 : 유지보수의 편의성과 같은 뜻으로, 실수를 줄인다는 것에 신뢰성 향상

## 함수 리터럴의 특징은 무엇인가요?
- 함수 이름은 **함수 몸체** 내에서만 참조할 수 있는 식별자
- 함수 이름의 유무로, 있으면 **기명 함수**, 없으면 **익명 함수**
- **각 매개변수**는 함수를 호출할 때 **지정한 인수**가 **순서대로** 할당되기 때문에 **순서에 의미 존재**
- **매개변수**는 **함수 몸체**(코드 블록) 내에서 **변수**와 동일하게 취급
- 함수 **'리터럴'** 이어서 값으로 취급
    - 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 **값을 생성**하는 표기 방식

## 함수를 정의하는 4가지 방법은 무엇인가요?
- 함수 선언문(권장하지 않음)
```javascript
function add(x, y) {
    return x + y;
}
```
- 함수 표현식(권장)
```javascript
var x = function (x, y) {
    return x + y;
}
```
- Function 생성자 함수(권장하지 않음)
```javascript
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```
- 화살표 함수
```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
* * *
## 함수를 '선언'하지 않고 '정의'한다고 표현하는 이유는 무엇인가요?
함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 **함수 객체**가 할당되기 때문입니다. 변수(식별자)는 무조건 undefined가 할당되기 때문에 선언한다고 일컫는 게 아닐까 싶네요.

* * *

```javascript
function foo() {console.log('foo');}
foo(); // foo

(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```

## 위 코드에서, foo는 함수 본체가 그대로 호출되지만 bar는 ReferenceError가 나오는데, 이유가 무엇인가요?
둘 다 대강 살펴보면 같은 함수 선언문인데, **그룹 연산자의 유무**에 차이가 있습니다. 우선 **함수 선언문**은 자바스크립트 엔진에 의해서 **값으로 평가되어야** 하는 경우 **기명 함수 리터럴**로 변경됩니다. **그룹 연산자**는 **값으로 평가되는 표현식**을 감싸기 때문에, **함수 리터럴**의 함수 이름은 **함수 몸체 내에서만 참조할 수 있는 식별자**인 반면에 **함수 선언문**은 **자바스크립트 엔진이 암묵적으로 함수 이름과 맞는 식별자를 생성**해 줍니다. 그래서 foo는 오류가 없고 bar의 경우 ReferenceError가 발생하는 것입니다.

## 함수를 함수 이름으로 호출하는 게 아니라, 함수 객체를 가리키는 식별자로 호출한다는 게 뭐에요?
- 함수 선언문의 경우 자바스크립트 엔진이 암묵적으로 식별자 add를 생성
- 함수 리터럴의 경우 개발자가 직접 변수에 할당하기 때문에 암묵적 생성이 필요 X

즉, 함수 이름은 그저 함수 객체를 가리키는 식별자를 만들기 위한 수단일 뿐임.

## 함수는 일급 객체잖아요, 일급 객체가 뭐였죠?
### 값의 성질을 갖는 객체.
함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미. 그래서 함수 리터럴이 가능한 것이고 아래의 코드와 같이 변수에 할당이 가능
```javascript
var add = function (x, y) { // 익명 함수
    return x + y;
}

console.log(add(2, 5)); // 7
```

## 함수 선언문과 함수 표현식의 차이는 무엇인가요?

- 함수 선언문은 표현식이 아닌 문이고 함수 리터럴은 표현식인 문이기 때문에 미묘하지만 중요한 차이가 존재
- 함수 선언문은 런타임 이전에 먼저 실행(함수 호이스팅)
- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이기 때문에, 변수 초기화와 동일함. 그래서 런타임에 평가. 즉 함수 호이스팅은 불가능하지만 변수 호이스팅은 발생할 수 있음.(var로 작성하였을 시)

## 함수 표현식과 함수 리터럴의 차이는 무엇인가요?
```javascript
// 함수 표현식 (변수의 초기화와 같이)
var x = function (num) {
    console.log(num);
}

// 함수 리터럴
function printNum(num) {
    console.log(num);
}
```

## 함수 호이스팅이 문제가 되는 이유
함수를 선언해야 한다는 당연한 규칙이 있는데, 이를 무시했기 때문입니다. 그렇기 때문에 더글라스 크락포드(자바스크립트 언어 개발에 참여, JSON을 창안)는 함수 선언문 대신 함수 표현식을 사용할 것을 권장합니다.

## 화살표 함수는 무엇인가요?
- 항상 익명 함수로 정의
- function 키워드 대신 화살표 =>를 사용
- 함수 표현식과는 달리 표현과 내부 동작 또한 간략화됨
    - 생성자 함수로 사용할 수 없음
    - 기존 함수와 this 바인딩 방식이 다름
    - prototype 프로퍼티 X
    - arguments 객체 생성 X

## 매개변수의 동작 방식은 어떤가요?
변수와 동일하기 때문에, 매개'변수'라고 불리는 것입니다. 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당됩니다. 함수가 호출될 때마다 매개변수는 이와 같은 단계를 거칩니다.

## 매개변수의 개수에 비해 인수가 더 많으면, 어떡하죠?
매개변수보다 인수가 더 많은 경우 초과된 인수는 무시됩니다. 하지만 초과된 인수가 그냥 버려지는 것은 아닙니다. 이는 암묵적으로 arguments 객체의 프로퍼티로 보관됩니다.

*arguments 객체는 가변 인자 함수(매개변수 개수를 확정할 수 없을 때 사용)를 구현할 때 유용하게 사용됩니다.*

## 매개변수에 잘못된 값이 들어오거나 값이 할당되지 않으면 어떡하죠?
자바스크립트는 부적절한 호출을 런타임에만 처리할 수 있기 때문에,
이는 타입스크립트라는 자바스크립트의 상위 확장을 도입해서 컴파일 시점에 부적절한 호출을 방지할 수 있게 합니다.
값이 할당되지 않았을 경우에는 매개변수 기본값을 이용해서 오류를 방지하면 됩니다.

## 함수의 매개변수는 얼마나 많이 추가하면 좋을까요?
매개변수는 많아지면 함수가 여러 가지 일을 한다는 증거이므로 바람직하지 않습니다. **이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 합니다.** 그렇기 때문에 **최대 3개 이상을 넘지 않는 것을 권장**합니다. 만약 3개 이상으로 만들어야 한다면, **하나**의 매개변수를 선언하고 **객체를 인수로 전달**하는 것이 유리합니다.

## 반환문의 역할 두 가지는 무엇인가요?
- 함수의 실행을 중단하고 함수 몸체 탈출
- return 키워드 뒤에 오는 표현식을 평가해 반환, return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined 반환

*반환문은 함수 몸체 내부에서만 사용할 수 있으며, 전역에서 반환문을 사용할 시 SyntaxError 발생*

## 인수로 원시 값을 받았을 경우와 객체를 받았을 경우의 차이는 무엇인가요?
- 값을 복사한다는 것은 같다.
    - 원시 값은 값 자체를 복사하기 때문에 원래의 변수에 어떠한 변경도 없다.
    - 객체는 참조 값을 복사하기 때문에 만약 조작이 있을 시에 원래의 변수에도 변형이 생긴다.

## 함수가 외부 상태를 변경하면 일어나는 문제점은 무엇인가요? 

*함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워지므로, 함수 내부의 동작을 유심히 관찰하지 않으면 외부 상태가 변하는지 알기 어렵기 때문에, 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. 때문에 참조에 의한 전달의 경우 **옵저버 패턴**을 통해 대처하거나 애초에 객체를 **불변 객체**로 만들어 사용하면 좋다. 또한 깊은 복사를 사용하여 원본 객체를 완전히 복제하는 것도 나쁘지 않은 생각입니다.*

## 깨알 함수형 프로그래밍 알아보기
아예 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라고 합니다. 순수 함수를 통해 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 **함수형 프로그래밍**이라고 합니다.

## 함수의 형태로는 무엇이 있나요?
### 즉시 실행 함수
- 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지할 수 있다.
### 재귀 함수
- 함수가 자기 자신을 호출하는 것을 재귀 호출, 재귀 함수는 자기 자신을 호출하는 행위. 즉 재귀 호출을 수행하는 함수
- 반복되는 처리를 위해 사용
- 181쪽의 2번째 문장에서 "함수 이름은 함수 몸체 내부에서만 유효하다."라고 했는데, 이유는 외부에서 접근할 때는 자바스크립트 엔진이 함수 이름을 토대로 만들어 준 식별자를 이용하기 때문입니다.
- *중요* : 재귀 함수는 자신을 무한 재귀 호출하기 때문에, 재귀 호출을 멈출 수 있는 **탈출 조건**을 반드시 만들어야 합니다. 만들지 아니할 시에 스택 오버플로 에러가 발생합니다.
- 반복문보다 직관적으로 이해하기 쉬울 때만 사용
### 중첩 함수
- 함수 내부에 정의된 함수를 뜻함.
- 중첩 함수를 포함하는 함수는 외부 함수로부름. 중첩 함수는 외부 함수 내부에서만 호출가능
- 외부 함수를 돕는 *헬퍼 함수* 역할을 함.
- 스코프와 클로저에 깊은 관련이 있다.
### 콜백 함수
- 함수의 매개변수를 통해 함수를 전달받을 수있는 일급 객체의 특성을 이용한 함수
- 함수의 매개변수를 통해 다른 함수의 내부로전달되는 함수를 뜻합니다. 그리고 이를 전달받은 함수는 고차 함수라고 말합니다.(함수를전달 받을 때는 함수 호출이 아닌 함수 자체를전달 받아야 합니다.)
- 중첩 함수와 비슷하게 헬퍼 함수의 역할을수행하지만 매개변수로 함수를 주고받기 때문에자유롭게 교체하기 쉽다는 장점까지 갖고 있음. 
- 고차 함수는 필요에 따라 콜백 함수에 인수를전달 가능
- 콜백 함수는 고차 함수에만 이용된다면 익명 함수 리터럴로 정의하는 게 일반적입니다. 아래의 코드 참조
```javascript
// 일회성 (쓸 때마다 새로 객체를 생성)
repeat(5, function (i) {
    if(i % 2) console.log(i);
});
```
```javascript
// 자주 쓰인다면 이렇게 (계속 쓰여도 번만 객체가 생성된 후로 생성 X)
var logOdds = function (i) { 
    if (i % 2) console.log(i);
};
repeat(5, logOdds);
```
- 비동기 처리, 배열 고차 함수에 중요한 패턴

## 순수 함수
### 순수 함수 되짚어보기
- 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 **부수 효과**가 없는 함수, 즉 언제나 동일한 인수에는 동일한 값이 반환 된다.
- 인수를 전달 받지 않으면 상수와 같기 때문에 인수가 없으면 의미 X
- 인수의 불변성을 유지
### 그렇다면, 비순수 함수는?
- 순수 함수의 반대, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 **부수 효과**가 있는 함수
- 함수 내부 상태에만 의존한다 해도(여기까지는 순수 함수), 내부 상태가 호출될 때마다 변화하는 값(예 : 현재 시간) 이라면 순수 함수 X










