# 실행 컨텍스트
실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 핵심 개념이기 때문에, 이를 바르게 이해하면 중요한 핵심 개념 여러 가지를 이해할 수 있습니다!

## 소스 코드의 타입
소스 코드의 타입으로는
- 전역 코드
- 함수 코드

등이 존재합니다. 이들은 해당 이름에 존재하는 소스 코드를 말하는데, 안에 있는 함수나 클래스는 포함하지 않고 말하는 것입니다.

### 소스 코드를 구분하는 이유는 무엇일까요?
소스 코드의 타입에 따라, 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문입니다. 차차 알아가 봅시다.

## 소스 코드의 평가와 실행
모든 소스 코드는, 중요한 두 가지 과정으로 나뉘어 준비합니다. 

### 1. 소스 코드의 평가
소스 코드의 평가 과정에서는, 변수 함수 등의 선언문을 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 렉시컬 환경의 환경 레코드, 같은 말로 스코프에 등록합니다.

### 2. 소스 코드의 실행
할당문에서 발견한 식별자가 선언된 변수인지 확인하고, 선언된 변수라면 할당 결과를 실행 컨텍스트에 등록하여 관리합니다.

## 실행 컨텍스트의 역할
코드가 실행되려면, 스코프를 구분하여 식별자와 바인딩된 값이 관리되어야 하고, 스코프 체인을 형성하여 식별자를 검색도 할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 합니다. 또 함수 호출이 종료될 시에 함수 호출 이전으로 돌아가기 위해 코드 실행 순서도 관리될 필요가 있습니다. 그렇기 때문에, 요약하자면

1. 스코프로 식별자와 바인딩된 값 관리
2. 스코프 체인을 형성할 수 있게 관리
3. 코드의 실행 순서 변경과 되돌아갈 수 있게 관리

할 수 있어야 합니다. 그러면 
### 이 역할을 누가 수행할까?
실행 컨텍스트가 수행합니다. 1번과 2번은 실행 컨텍스트의 렉시컬 환경으로 관리하고, 3번은 실행 컨텍스트 스택으로 관리합니다.

## 실행 컨텍스트 스택
말 그대로 스택이라는 자료구조로 실행 컨텍스트를 관리합니다. 코드로 예를 들어보겠습니다.
```javascript
const x = 1;

function foo () {
  const y = 2;
  
  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```
우선 '전역 실행 컨텍스트'에 대해서 얘기가 시작됩니다.

1. 전역 코드를 평가하는 단계에서, 전역 실행 컨텍스트를 생성하고, 실행 컨텍스트 스택에 전역 실행 컨텍스트가 올라가게 됩니다. 이 때 const 변수 x를 평가하고, foo 함수를 평가하였습니다.
2. 이제 평가가 끝났으니, 전역 실행 컨텍스트가 코드를 실행합니다. x에 값 1을 바인딩해주고, foo 함수를 호출하면? foo 함수 내부로 빨려 들어갑니다. 그러면 실행 순서가 자연스럽게 바뀝니다. 함수도 실행 컨텍스트가 존재하고, 즉 평가 단계가 존재하기 때문에 이제 foo 함수로 이야기가 넘어갑니다.
3. foo 함수의 평가가 시작됩니다. 함수 실행 컨텍스트를 생성합니다. 함수 실행 컨텍스트에 평가한 것들을 넣습니다. 이제 함수 실행 컨텍스트로 실행합니다. y에 2라는 값을 바인딩합니다. 그리고 bar를 실행합니다. 이제 bar이라는 마지막 이야기로 넘어갑니다.
4. bar 함수의 평가가 시작됩니다. 함수 실행 컨텍스트를 생성합니다. z를 평가합니다. console 객체는 bar 함수의 객체가 아니기에 평가를 하지 못합니다. 이제 실행하는데요, z에 값을 바인딩해주고, console.log 메서드를 호출한 이후 bar 함수가 종료됩니다.
5. 종료됐다는 뜻은 실행 컨텍스트 스택에서 팝된다는 뜻입니다. bar 함수의 함수 실행 컨텍스트 스택이 팝 됩니다.
6. foo 함수의 것도 종료됐으니 팝 됩니다.
7. 전역 코드의 것도 종료 됐으니 팝 됩니다.

#### 실행 중인 실행 컨텍스트란, 스택의 최상위에 있는 것을 말합니다.

## 렉시컬 환경
렉시컬 환경은 스코프(객체입니다.)를 생성하여 식별자를 키로 등록하고, 식별자에 바인딩된 값을 관리합니다. 앞선 실행 컨텍스트 스택의 예를 드는 과정에서, x y z를 평가하는 것도 해당 스코프에 키로 등록되는 것이었습니다.

### 렉시컬 환경은 두 가지 컴포넌트로 구성됩니다.
- 환경 레코드 : 식별자와 값을 관리하는 저장소입니다. 이는 소스코드의 내용에 따라 관리하는 내용과 구성에 차이가 있습니다.
- 외부 렉시컬 환경에 대한 참조 : 상위 스코프를 가리킵니다. 즉, 자신의 코드를 포함하고 있는 바로 상위의 렉시컬 환경을 말합니다.

## 실행 컨텍스트의 생성과 식별자 검색 과정
전역 변수 var, const 각각 1개와 함수 선언문 하나가 있다고 상상해 봅시다. 이걸로 어떻게 실행 컨텍스트가 생성되고 코드 실행 결과가 관리되는지, 실행 컨텍스트를 통해 식별자를 검색하는지 살펴보겠습니다.

### 1. 전역 객체 생성
전역 코드가 평가되기 이전에 생성됩니다.
전역 객체도 Object.prototype을 상속받기에 프로토타입 체인의 일원입니다.

### 2. 전역 코드 평가
소스코드가 로드되면 전역 코드를 평가합니다. 즉, 전역 객체 생성이 먼저인 이유는 소스코드가 즉각적으로 로드되지 않기 때문입니다. 전역 코드 평가의 순서는 이렇습니다.

1. 전역 실행 컨텍스트 생성
2. 전역 렉시컬 환경 생성
	1. 전역 환경 레코드 생성
    	1. 객체 환경 레코드 생성
        2. 선언적 환경 레코드 생성
	2. this 바인딩
    3. 외부 렉시컬 환경에 대한 참조 결정

이전까지의 것은 개념만 기억하여도 좋습니다. 여기부터 진짜입니다. 함께 보시지요

#### 1번의 과정
비어있는 전역 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시합니다. 이 때, 전역 실행 컨텍스트는 실행 중인 실행 컨텍스트가 됩니다.

#### 2번의 과정
전역 렉시컬 환경을 생성하고, 전역 실행 컨텍스트에 바인딩합니다. 즉 전역 실행 컨텍스트에 연결되어 있는 LexicalEnvironment에 바인딩하는 것과 같습니다.

#### 2-1번의 과정
이제 전역 렉시컬 환경의 스코프인 전역 환경 레코드를 생성합니다. 전역 환경 레코드는 전역 스코프, 전역 객체의 것들을 제공합니다. 여기에서 ES6 이후로 let, const 키워드가 등장하여 전역 프로퍼티가 되지 않을 변수가 생겼기에 객체 환경 레코드와, 선언적 환경 레코드로 나뉩니다.

#### 2-1-1번의 과정
객체 환경 레코드 생성, 객체 환경 레코드는 BindingObject 객체와 연결됩니다. 이는 전역 객체와 바인딩되어 있습니다. 즉, 실행 컨텍스트를 통하여, 더 상세히는 렉시컬 환경을 통하여 식별자와 그의 값을 관리한다고 했다는 것은, 전역 변수나 전역 함수는 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 되는 것이라고 보면 됩니다. 이 때, 전역 변수 x는 평가 단계에서 선언과 초기화가 동시에 진행되기에 undefined 값이 들어올 수 있는 것이었습니다. 그래서 호이스팅이 발생하는 것이구요.

#### 2-1-2번의 과정
선언적 환경 레코드 생성, 이는 let, const 키워드를 관리합니다. 전역 객체의 프로퍼티가 되지 않고 어떠한 개념적인 블록에 관리된다고 보면 되는데, 그 개념적인 블록이 바로 이 선언적 환경 레코드입니다. 하지만 let, const는 선언과 동시에 초기화가 되지 않기 때문에, 초기화 이전까지의 런타임에서 참조를 할 수 없는 일시적 사각지대 현상이 발생합니다.

#### 2-2번의 과정
this 바인딩, 전역 코드에서 this를 참조했을 때 GlobalThisValue 내부 슬롯에 바인딩되어 있는 객체가 바인딩됩니다.

#### 외부 렉시컬 환경에 대한 참조 결정
이를 통해 단방향 링크드 리스트인 스코프 체인을 구현할 수 있습니다. 이는 자신의 코드를 포함하고 있는 바로 위의 렉시컬 환경을 참조하고 있는 것입니다.

### 전역 코드 실행
여기에서 x,y에 값이 할당되고, foo 함수가 호출됩니다.
함수부터 스코프 체인의 종점이 아니기 때문에, 식별자 결정이 필요합니다. 식별자 결정이란, 동일한 이름의 식별자는 여러 스코프에 각각 존재할 수 있기 때문에, 호출한 이를 결정할 필요가 있을 때 부르는 용어입니다. 식별자 결정을 위해 식별자를 검색할 때는, 실행 중인 실행 컨텍스트부터 외부 렉시컬 환경에 대한 참조 결정에 바인딩되어 있는 렉시컬 환경으로 거슬러 올라가며 찾습니다.
함수의 코드 평가는 전역의 코드 평가와는 다르게 함수 환경 레코드 하나로 모든 변수와 함수를 수용한다는 것을 제외하고는 같으므로 생략하도록 하겠습니다.

## console 식별자 검색을 해봅시다
전역에 함수 하나와 그의 중첩 함수 하나가 더 있다고 해봅시다. 중첩 함수에서 console.log를 호출했을 경우에..?

1. 먼저 console 식별자를 스코프 체인에서 검색합니다. 스코프 체인이란? 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작하여 외부 렉시컬 환경에 대한 참조로 이어지는 렉시컬 환경의 연속입니다.
2. 현재 실행 컨텍스트의 렉시컬 환경에 없네요. 그러면 위로 올라가서 찾아봅시다. 하지만 이 함수에도 없습니다.
3. 그러면, 마지막 수단으로 전역 렉시컬 환경으로 이동하여 검색합니다. 여기에서, 전역 환경 레코드의 객체 환경 레코드에 연결되어 있는 BindingObject의 바인딩된 전역 객체에서 찾을 수 있습니다. 여기에서 찾았으니, 이제 log 메서드를 찾을 차례입니다.
4. console 객체에서 log 메서드를 찾기 시작합니다. 프로토타입 체인으로요. console 객체 자체의 메서드이기 때문에 찾고, 호출하고, 종료합니다.

## 실행 컨텍스트와 블록 레벨 스코프
if문이나 for문같은 블록문에서 let 또는 const 변수가 발견되면, 잠깐 그 안에서 실행할 동안 블록 렉시컬 환경으로 전역 렉시컬 환경에서 전환합니다. 그 후에는 다시 전역 렉시컬 환경으로 돌아옵니다.
예시는 이것이었습니다.
```javascript
let x = 1;

if(true) {
  let x = 10;
  console.log(x); // 10
}
console.log(x); // 1
'''
