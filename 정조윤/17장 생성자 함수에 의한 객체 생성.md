생성자 함수에 의한 객체 생성
==========================
**이번 장에서는 객체 리터럴 사용 방식과 생성자 함수 사용 방식의 장단점을 비교합니다.**

## Object 생성자 함수 사용법
- Object 생성자 함수는 new 연산자와 함께합니다.
- 항상 빈 객체를 생성하여 반환하고, 이후에 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있습니다.
- 하지만 객체 리터럴을 사용하는 방법이 훨씬 간편하기 때문에 딱히 메리트가 없는 객체 생성 방법입니다.

## 생성자 함수 맛보기 전에 객체 리터럴의 문제점 알아보기
- 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 할 시 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적
    - 1, 2개라면 괜찮지만 객체를 수십 개 만들어야 한다면 문제가 큽니다.

## 생성자 함수란?
- 객체 리터럴의 딱 한 가지 단점을 멋지게 보완한 객체 생성 방법입니다.
    - 이의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화하는 것입니다.
        - 초기화는 선택입니다.
- 일반 함수와 동일한 방법으로 생성자 함수를 정의하고, new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작합니다.
    - 만약 new 연산자가 없다면, 일반 함수로 동작합니다.
    - new 연산자와 함께 생성자 함수를 호출하면 자바스크립트 엔진이 다음과 같은 과정을 거쳐 암묵적으로 인스턴스를 생성하고 인스턴스를 초기화한 후 암묵적으로 인스턴스를 반환합니다.

## 인스턴스 생성 과정은 어떻게 될까요?
1. 인스턴스 생성과 this 바인딩, 런타임 이전에 실행
    1. 빈 객체 생성
    2. 빈 객체를 this에 바인딩
2. 인스턴스 초기화
    - this에 바인딩된 인스턴스를 초기화, 이 처리는 개발자가 기술합니다.
3. 인스턴스 반환
    - 모든 처리가 끝나면 인스턴스가 바인딩된 this를 반환

## 생성자 함수 작성할 때의 중요한 점
위의 3번. 인스턴스 반환에서 this가 아닌 다른 객체를 명시적으로 반환하면 return 문에 명시한 객체가 반환되기 때문에 생성자 함수의 기본 동작을 훼손합니다. 따라서 생성자 함수 내부에서 return 문을 반.드.시 생략하게 합니다.

## 내부 메서드 [[Call]]과 [[Construct]] 알아보기
- 함수는 객체이므로 일반 객체와 동일하게 동작할 수 있습니다. 즉, 함수 객체는 일반 객체의 모든 내부 슬롯과 내부 메서드를 갖고 있습니다.
    - 하지만 일반 객체와 다른 점은 호출할 수 있다는 것입니다. 그렇기 때문에 추가적인 내부 슬롯([[Environment]], [[FormalParameters]]), 내부 메서드([[Call]], [[Construct]])를 가지고 있습니다.
        - 함수 표현식, 클래스(클래스도 함수입니다.)는 [[Construct]] 를 갖고 있지만,
        - 메서드, 화살표 함수는 [[Construct]]를 갖고 있지 않습니다.
            - 이 때 주의할 것은 ES 사양에서 메서드로 인정하는 범위가 일반적인 의미의 메서드보다 좁다는 것입니다.
            - 함수를 프로퍼티 값으로 사용하면 일반적으로 메서드로 통칭하지만, ES 사양에서 메서드란 **ES6의 메서드 축약 표현**만을 의미합니다. 따라서 함수의 위치가 아닌 함수 정의 방식에 따라 [[Construct]] 존재 여부를 구분하는 것입니다.
- 함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고 new 연산자로 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출됩니다.

## 일반 함수를 생성자 함수처럼 사용할 수 있나요?
- 주의할 것은, 생성자 함수로서 호출될 것을 기대, 정의하지 않은 일반 함수에 new 연산자를 붙여 호출해도 생성자 함수처럼 동작할 수 있습니다.
왜냐하면 메서드 축약 표현이나 화살표 함수만 아니면 모두 [[Construct]] 내부 메서드를 갖고 있기 때문입니다.
- 그렇기 때문에, 생성자 함수는 일반적으로 첫 문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력합니다.

## new 연산자의 유무로 어떤 내부 메서드가 실행되나요?
- new 연산자 O
    - [[Construct]]
- new 연산자 X
    - [[Call]]

## new 연산자 까먹었을 때 대처법
**new.target** 사용하기

IE(인터넷 익스플로러)는 new.target을 지원하지 않지만 사용자가 별로 없기에 신경 쓰지 않아도 될 것 같습니다.

함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있습니다. new 연산자의 유무에 따라 사용했을 시 new.target은 함수 자신을 가리키고, 사용하지 않았으면 undefined 값을 갖고 있습니다.
```javascript
function Circle(radius) {
    if(!new.target) {
        return new Circle(radius);
    }
    this.radius = radius;
    this.getDiameter = function () {
        return 2 * this.radius;
    }
}

const circle = Circle(5);
console.log(circle.getDiameter());
```
new.target을 쓰지 않고 생성자 함수로서 작동해야 할 함수가 일반 함수로 작동하면, 함수 내의 this는 전역을 가리키기 때문에 황당한 문제점들이 발생할 위험이 높습니다.

마지막
======
- new 연산자와 함께 생성자 함수에 의해 생성된 객체는 프로토타입에 의해 생성자 함수와 연결됩니다. 이를 이용하여 new 연산자와 함께 호출되었는지 확인할 수 있습니다. 
    - 프로토타입 : 어떤 객체의 상위 객체의 역할을 하는 객체입니다.
    - 프로토타입 체인 : 프로토타입이 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조를 말합니다.